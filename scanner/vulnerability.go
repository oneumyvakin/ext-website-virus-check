package main

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
)

type vulnerabilityDb struct {
	dbRootPath      string
	dbPath          string
	dbType          string
	dbRegistry      dbRegistry
	Vulnerabilities []Vulnerability
}

type dbRegistry struct {
	DbName    string
	DbVersion int
	Parts     []string
}

type Vulnerability struct {
	Error              programError
	Title              string
	CVE                string
	AdvisoryDate       string
	AdvisoryURL        string
	SoftwareType       string
	SoftwareName       string
	SoftwareVersion    string
	SoftwareAuthor     string
	SearchVersion      bool
	VersionFrom        string
	VersionTo          string
	DetectByPathExists bool
	Path               string
}

func (db *vulnerabilityDb) load(dbType string) (err error) {
	db.dbType = dbType
	db.dbPath = filepath.Join(db.dbRootPath, db.dbType)
	registryRemote := storagePath + "/" + db.dbType + "/" + "registry.json"
	registryPath := filepath.Join(db.dbPath, "registry.json")

	err = download(registryRemote, registryPath)
	if err != nil {
		err = fmt.Errorf("Failed DB registry %s download: %s. Skip", registryRemote, err)
		logger.Printf(err.Error())
		// do not fail if network issues
	}

	var f *os.File
	f, err = os.Open(filepath.Join(db.dbPath, "registry.json"))
	if err != nil {
		return
	}
	registry := dbRegistry{}
	err = json.NewDecoder(f).Decode(&registry)
	if err != nil {
		return
	}

	for _, part := range registry.Parts {
		err = db.loadPart(part)
		if err != nil {
			err = fmt.Errorf("Failed load DB part %s: %s", part, err)
			logger.Printf(err.Error())
			return
		}
	}

	db.dbRegistry = registry
	logger.Println("Loaded DB:", db.dbRegistry.DbName, "Version:", db.dbRegistry.DbVersion, "Vulnerabilities:", len(db.Vulnerabilities))
	return
}

func (db *vulnerabilityDb) loadPart(part string) (err error) {
	remotePart := storagePath + "/" + db.dbType + "/" + part
	path := filepath.Join(db.dbPath, part)
	logger.Println("Start load:", path)
	if _, err = os.Stat(path); err != nil && os.IsNotExist(err) {
		err = download(remotePart, path)
		if err != nil {
			err = fmt.Errorf("Failed DB part %s download: %s. Skip", remotePart, err)
			logger.Printf(err.Error())
			// do not fail if network issues
		}
	}

	if _, err := os.Stat(path); err != nil && os.IsNotExist(err) {
		return nil
	}

	f, err := os.Open(path)
	if err != nil {
		logger.Println(err)
		return
	}

	vulnDb := vulnerabilityDb{}
	err = json.NewDecoder(f).Decode(&vulnDb)
	if err != nil {
		return
	}

	db.Vulnerabilities = append(db.Vulnerabilities, vulnDb.Vulnerabilities...)
	logger.Println("Load DB part:", path, "Vulnerabilities:", len(vulnDb.Vulnerabilities))

	return
}
